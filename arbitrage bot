write a cosmwasm contract in rust for an arbitrage bot with a destination wallet and two contract addresses to arbitrage


// This contract will arbitrage between two contract addresses and a destination wallet.
// It will watch for price changes and if one of the contract addresses has a lower price, it will buy from it and sell to the other one.

extern crate cosmwasm_std;
use cosmwasm_std::{
    attr, to_binary, Api, Binary, Env, Extern, HandleResponse, InitResponse, Querier,
    Storage,
};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InitMsg {
    // address of the contract to buy from
    buy_from: String,
    // address of the contract to sell to
    sell_to: String,
    // address of the destination wallet
    destination_wallet: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ArbitrageOrder {
    from: String,
    to: String,
    amount: u64,
    price: u64,
}

fn init(
    deps: &mut Extern,
    env: Env,
    msg: InitMsg,
) -> Result<InitResponse, InitResponse> {
    let mut storage = deps.storage.as_mut().unwrap();
    storage
        .set(env.contract.as_slice(), &to_binary(&msg)?)
        .map_err(|e| InitResponse::err(e.into()))?;

    Ok(InitResponse::default())
}

fn handle(
    deps: &mut Extern,
    env: Env,
    msg: ArbitrageOrder,
) -> Result<HandleResponse, HandleResponse> {
    let mut storage = deps.storage.as_mut().unwrap();
    // get state from storage
    let state: InitMsg = match storage.get(env.contract.as_slice()) {
        Ok(Some(binary)) => match from_binary(&binary) {
            Ok(s) => s,
            Err(_) => return Err(HandleResponse::err("Invalid state format")),
        },
        Ok(None) => return Err(HandleResponse::err("State not found")),
        Err(e) => return Err(HandleResponse::err(e.into())),
    };

    // check if the order is from one of the two contracts
    if !(msg.from == state.buy_from || msg.from == state.sell_to) {
        return Err(HandleResponse::err("Order is not from either contract"));
    }

    // check if the order is to the destination wallet
    if msg.to != state.destination_wallet {
        return Err(HandleResponse::err("Order is not to the destination wallet"));
    }

    // check if the order amount and price are valid
    if msg.amount == 0 || msg.price == 0 {
        return Err(HandleResponse::err("Invalid amount or price"));
    }

    // get current price from contract
    let current_price: u64 = match deps.api.query_contract(
        &state.buy_from,
        &"price".as_bytes(),
        &[],
    ) {
        Ok(Some(Binary(binary))) => match binary.as_ref() {
            [price] => *price,
            _ => return Err(HandleResponse::err("Invalid price")),
        },
        Ok(None) => return Err(HandleResponse::err("No price found")),
        Err(e) => return Err(HandleResponse::err(e.into())),
    };

    // check if the price has changed
    if msg.price == current_price {
        return Ok(HandleResponse::default());
    }

    // buy from the contract with the lower price
    let from_contract: &str = if msg.price < current_price {
        &state.buy_from
    } else {
        &state.sell_to
    };

    // create buy order
    let buy_msg = to_binary(&ArbitrageOrder {
        from: from_contract.to_string(),
        to: state.destination_wallet.clone(),
        amount: msg.amount,
        price: msg.price,
    })?;

    // submit buy order
    deps.api.send_msg(&from_contract, &buy_msg)?;

    // create sell order
    let sell_msg = to_binary(&ArbitrageOrder {
        from: state.destination_wallet.clone(),
        to: state.sell_to.clone(),
        amount: msg.amount,
        price: current_price,
    })?;

    // submit sell order
    deps.api.send_msg(&state.sell_to, &sell_msg)?;

    Ok(HandleResponse::default())
}

fn query(
    deps: &Extern,
    _env: Env,
    _msg: Vec<u8>,
) -> Result<Binary, HandleResponse> {
    // Return empty response
    Ok(Binary(Vec::new()))
}

#[cfg(test)]
mod tests {
    use super::*;
    use cosmwasm_std::testing::{mock_dependencies, mock_env, MockApi};
    use cosmwasm_std::{coins, from_binary, Api, StdError, StdResult, Storage};

    #[test]
    fn proper_initialization() {
        let mut deps = mock_dependencies(20, &[]);

        let msg = InitMsg {
            buy_from: "contract1".to_string(),
            sell_to: "contract2".to_string(),
            destination_wallet: "wallet".to_string(),
        };
        let env = mock_env("contract", "creator", &coins(1000, "earth"));

        // we can just call .unwrap() to assert this was a success
        let res = init(&mut deps, env, msg).unwrap();
        assert_eq!(0, res.messages.len());

        // it worked, let's query the state
        let res = deps
            .storage
            .get(b"contract")
            .expect("no data stored");
        let value: InitMsg = from_binary(&res).expect("invalid data stored");
        assert_eq!(msg, value);
    }

    #[test]
    fn handle_arbitrage_order() {
        let mut deps = mock_dependencies(20, &coins(1000, "token"));

        let msg = InitMsg {
            buy_from: "contract1".to_string(),
            sell_to: "contract2".to_string(),
            destination_wallet: "wallet".to_string(),
        };
        let env = mock_env("contract", "creator", &coins(1000, "earth"));

        // we can just call .unwrap() to assert this was a success
        let _res = init(&mut deps, env, msg).unwrap();

        // set contract1 price to 10
        deps.api.set_contract_result(
            "contract1",
            &"price".as_bytes(),
            &to_binary(&[10])
                .expect("binary conversion should work for u64"),
        );

        // create arbitrage order where price is lower than current price
        let msg = ArbitrageOrder {
            from: "contract1".to_string(),
            to: "wallet".to_string(),
            amount: 1,
            price: 5,
        };
        let env = mock_env("contract", "creator", &coins(1000, "earth"));

        // we can just call .unwrap() to assert this was a success
        let _res = handle(&mut deps, env, msg).unwrap();

        let buy_msg = to_binary(&ArbitrageOrder {
            from: "contract1".to_string(),
            to: "wallet".to_string(),
            amount: 1,
            price: 5,
        })
        .expect("binary conversion should work");

        let sell_msg = to_binary(&ArbitrageOrder {
            from: "wallet".to_string(),
            to: "contract2".to_string(),
            amount: 1,
            price: 10,
        })
        .expect("binary conversion should work");

        // make sure the correct messages were sent
        let msgs = deps.api.sent_messages();
        assert_eq!(2, msgs.len());
        assert!(msgs.contains(&("contract1".to_string(), buy_msg)));
        assert!(msgs.contains(&("contract2".to_string(), sell_msg)));
    }
}
